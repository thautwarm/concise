import std.common.[Space Name DoubleQuotedStr]
ignore [Space]
[python] import reley.expr_based_ast.[*]
[python] import reley.helper.[*]
[python] import functools.[*]
[python] import rbnf.std.common.[recover_codes]

num := R'0[Xx][\da-fA-F]+|\d+(?:\.\d+|)(?:E\-{0,1}\d+|)'
lam := R'\\'

to_const cast := 'type' 'fn' 'def' '->' '[|' '|]' 'return' 'if' 'else' 'let' 'or' 'and' 'not' 'xor' '..' '::' 'in' '<-' 'then' 'infix' '=='

identifier ::= mark=Name | '(' as mark ID=binOp ')' -> Operator(loc @ mark, ID.name if ID else mark.value)

def_lambda ::= mark=lam fn=lambda_trailer -> DefFun(loc @ mark, None, fn.args, fn.body)

lambda_trailer ::= (mark='(' args=arguments ')' | args=(mark=arg){1 1}) ('->' body=expr |  body=lambda_trailer)
                   -> DefFun(loc @ mark, None, args or (), body)

def_fun    ::= id=identifier fn=fun_trailer -> DefFun(loc @ id, id.name, fn.args, fn.body)

fun_trailer ::= (mark='(' args=arguments ')' | args=(mark=arg){1 1}) ('=' body=expr | body=fun_trailer)
                -> DefFun(loc @ mark, None, args or (), body)

defty ::= mark='type' id=identifier '=' ty=ty
         -> DefTy(loc @ mark, id.name, ty)

arguments ::= head=arg tail=(',' arg)* -> [head, *tail[1::2]]
arg   ::= name=Name [':' ty=ty] -> Arg(loc @ name, name.value, ty)
ty    ::= it=expr -> it

infix ::= mark='infix' precedence=num op=identifier
          -> Infix(loc @ mark, eval(precedence.value), op.name)

stmt  ::= expr=def_fun | expr=expr -> expr

_where  ::= name=Name '=' expr=expr -> Where(loc @ name, name.value, expr)

expr ::=
    | BIN=expr (binOp expr)+ as tail
    | JUST=factor
    ->  if BIN : return BinSeq(loc @ BIN, [BIN, *tail]) if tail else BIN
        return JUST

binOp   ::=
        | ('or' | '-' | 'and') as basic
        | '`' names=(~'`')+ '`'
        | ('*' | '^' | '%' | '&' | '@' | '$' | '+' | '/' | '|' | '>' | '<' | '==' | '~' | '.' | '?' | '!' | '::')+ as seq
        ->
            Operator(loc @ basic, basic.value) if basic else\
            Operator(loc @ names[0], recover_codes(names)) if names else\
            Operator(loc @ seq[0], ''.join(map(lambda _: _.value, seq)))

factor ::= [neg='-'] call=call
            -> Call(loc @ neg, Symbol(loc@neg, "neg"), call) if neg else call

void ::= '(' as mark ')' -> Void(loc@mark)

call ::= leader=atom tail=(atom{is_indented})*

         ->  reduce(lambda a, b: Call(loc @ a, a, b), tail, leader)

atom ::= | NUM=num
         | STR=DoubleQuotedStr
         | SYMBOL=identifier
         | SUITE='{' [suites as stmts] '}' ['where' '{' lazy=_where* '}']
         | IF='if' cond=expr 'then'
            iftrue=expr
             'else'
            iffalse=expr
         | LET='let'
             id=identifier '=' expr=expr
              'in'
             out=expr
         | RET='return' [expr=expr]
         | INFIX = infix
         | YIELD='yield' [expr=expr]
         | JUST=(void | def_lambda | defty)
         | '(' JUST=expr TUPLE=(',' expr)* ')'
         ->
            if IF:     return If(loc @ IF, cond, iftrue, iffalse)
            if LET:    return Let(loc @ LET, id.name, expr, out)
            if SUITE:  return Suite(loc @ SUITE, stmts, lazy or ())
            if RET:    return Return(loc @ RET, expr)
            if YIELD:  return Yield(loc @ YIELD, expr)
            if INFIX:  return INFIX
            if NUM:    return Number(loc @ NUM, eval(NUM.value))
            if STR:    return Str(loc @ STR, eval(STR.value))
            if JUST:   return JUST if not TUPLE else Tuple(loc @ JUST, (JUST, *TUPLE[1::2]))
            return Symbol(loc @ SYMBOL, SYMBOL.name)
suites ::=  leader=stmt [(stmt{is_aligned})+] as tail -> [leader, *tail]

module ::=  leader=stmt [(stmt{is_aligned})+] as tail ->  Module(loc, [leader, *tail], ())