import std.common.[Space Name DoubleQuotedStr]
ignore [Space]
[python] import reley.expr_based_ast.[*]
[python] import reley.helper.[*]
[python] import functools.[*]

num := R'0[Xx][\da-fA-F]+|\d+(?:\.\d+|)(?:E\-{0,1}\d+|)'
lam := R'\\'

to_const cast := 'type' 'fn' 'def' '->'
                 '[|' '|]'
                 '{|' '|}'
                 'return' 'if' 'else' 'let' 'or' 'and' 'not' 'xor' 'where'
                 '..' '::' 'in' '<-' 'then' 'infix' '=='

identifier ::= mark=Name | '(' as mark ID=binOp ')' -> Operator(loc @ mark, ID.name if ID else mark.value)

def_lambda ::= mark=lam fn=lambda_trailer -> Lam(loc @ mark, None, fn.args, fn.body)

lambda_trailer ::= (mark='(' args=[arguments] ')' | args=(mark=arg){1 1}) ('->' body=expr_stmts |  body=lambda_trailer)
                   -> Lam(loc @ mark, None, args or (), body)

define     ::= id=identifier fn=fun_trailer
               ->
                  if isinstance(fn, Lam):
                    return DefFun(loc @ id, id.name, fn.args, fn.body)
                  else:
                    return DefVar(loc @ id, id.name, fn)

fun_trailer ::= '=' body=expr_stmts | ((mark='(' args=[arguments] ')' | args=(mark=arg){1 1}) fun=fun_trailer)
                ->  Lam(loc @ mark, None, args or (), fun) if fun else body

defty ::= mark='type' id=identifier '=' ty=ty  -> DefTy(loc @ mark, id.name, ty)

arguments ::= head=arg tail=(',' arg)* -> [head, *tail[1::2]]

arg   ::= name=Name [':' ty=ty] -> Arg(loc @ name, name.value, ty)

ty    ::= it=expr -> it

infix ::= mark='infix' precedence=num op=identifier -> Infix(loc @ mark, eval(precedence.value), op.name)

expr ::=| BIN=expr (binOp expr)+ as tail
        | JUST=factor
        ->  if BIN : return BinSeq(loc @ BIN, [BIN, *tail]) if tail else BIN
            return JUST

binOp   ::=
        | ('or' | '-' | 'and') as basic
        | '`' names=(~'`')+ '`'
        | ('*' | '^' | '%' | '&' | '@' | '$' | '+' | '/' | '|' | '>' | '<' | '==' | '~' | '.' | '?' | '!' | '::')+ as seq
        -> bin_op_rewrite(state.ctx.get)

factor ::= [neg='-'] call=call -> Call(loc @ neg, Symbol(loc@neg, "neg"), call) if neg else call

call ::= leader=atom tail=(atom{is_indented})*
         ->  reduce(lambda a, b: Call(loc @ a, a, b), tail, leader)

atom ::= | '{|' as mark expr_stmts '|}'
         | SYMBOL=identifier
         | IF='if' cond=expr 'then' iftrue=expr_stmts 'else' iffalse=expr_stmts
         | LET='let' stmts=stmts 'in' out=expr_stmts
         | RET='return' [expr=expr_stmts]
         | YIELD='yield' [expr=expr_stmts]
         | STRS=DoubleQuotedStr+
         | NUM=num
         | LITERAL=literal
         -> atom_rewrite(state.ctx.get)

tuple ::= '(' as mark [head=expr tail=(',' expr)*] ')'
          -> if tail: return Tuple(loc @ mark, (head, *tail[1::2]))
             if head: return head
             Void(loc@mark)

list  ::= '[' as mark  [head=expr tail=(',' expr)*] ']' -> HList(loc @ mark, (head, *tail[1::2]) if head else ())

set   ::= '{' as mark head=expr tail=(',' expr)* '}' -> HDict(loc @ mark, make_set(head, *tail[1::2]))

dict  ::= '{' as mark head=pair tail=(',' pair)* '}' -> HDict(loc @ mark, (head, *tail[1::2]))

pair  ::= key=expr ':' value=expr -> (key, value)

literal ::= it=(tuple | list | set | dict | def_lambda) -> it

suites     ::= '{|' as mark expr=expr_stmts '|}'
               -> expr.loc.update(*(loc @ mark))
                  expr

expr_stmt  ::= expr=expr [';'] -> expr

expr_stmts ::= (leader=expr_stmt [(expr_stmt{is_aligned})+] as tail | '{|' expr_stmt+ as no_indented '|}') ['where' stmts=stmts]
             -> suite = Suite(loc @ leader, no_indented or [leader, *tail])
                if stmts:
                  return Where(loc @ leader, suite, stmts)
                suite
stmt   ::=
       | it=define [';']
       | it=defty  [';']
       | it=infix  [';']
       -> it

stmts  ::= leader=stmt [(stmt{is_aligned})+] as tail | '{|' stmt+ as no_indented '|}'
           -> Definition(loc @ leader, no_indented or [leader, *tail])

module ::= it=stmts -> Module(it)
